#!/usr/local/bin/node

/**
 * Cleans up the package.xml file in various ways, either by excluding metadata types or isolating them out
 * Useful for fixing sfdx conversion errors ("MatchingRules" and "Workflow" is not a real metadata API type)
 * Useful for stripping out members we don't want deleted from a destructiveChange.xml (standard QuickActions)
 * Useful for isolating metadata types into destructiveChanges.xml (delete Layouts by itself before deleting everything else)
 */

var fs = require('fs');

var inFile = 'deploy/package.xml';
var outFile = 'deploy/package.xml';
var types = 'MatchingRules,Workflow';
var members = 'LogACall,NewCase,NewContact,NewEvent,NewLead,NewNote,NewOpportunity,NewTask,SendEmail';
var showOnly = false;

// Handle command line arguments, all optional
var arg = 2;
while (arg < process.argv.length) {
    var argName = process.argv[arg];
    if (argName == '-h') {
        console.log('Usage:');
        console.log('\t-i: In Filename (default: deploy/package.xml');
        console.log('\t-o: Out Filename (default: deploy/package.xml');
        console.log('\t-t: Types to handle, comma separated (default: MatchingRules)');
        console.log('\t-m: Members to always exclude, comma separated (default: LogACall,NewEvent,NewTask,SendEmail)');
        console.log('\t-s: Copy ONLY what is in types rather than exclude it');
        console.log('');
        console.log('Example of using command line arguments rather than the defaults:');
        console.log('Create package.xml with JUST the Layout and CompactLayout types:');
        console.log('\t' + process.argv[1] + ' -i newsrc/package.xml -o newdestroy/destructiveChanges.xml -s -t Layout,CompactLayout');
        return;
    } else if (argName == '-i') {
        inFile = process.argv[arg+1];
        arg += 2;
    } else if (argName == '-o') {
        outFile = process.argv[arg+1];
        arg += 2;
    } else if (argName == '-t') {
        types = process.argv[arg+1];
        arg += 2;
    } else if (argName == '-m') {
        members = process.argv[arg+1];
        arg += 2;
    } else if (argName == '-s') {
        showOnly = true;
        arg++;
    }
}
var typeList = types.split(',');
var memberList = members.split(',');

console.log('Cleaning up ' + inFile + ' into ' + outFile);
if (showOnly) {
    console.log('Copying only the following:');
} else {
    console.log('Excluding:');
}
console.log('Types: ' + typeList);
console.log('Members: ' + memberList);

fs.readFile(inFile, 'utf8', function(err, data) {
    if (err) {
        return console.log(err);
    }
    var lines = data.split('\n');
    var outputStr = '';
    var hideThis = false;

    // Go line by line
    for (var i = 0;i < lines.length;i++) {
        if (lines[i].includes('<types>')) {
            // At the start of a types section, check for a line with the name, which could be the first line or the last line
            // depending on if this xml was generated by sfdx or the org.
            // Depending on if we want to exclude or isolate, determine if we want to show this section or not
            hideThis = showOnly;
            for (var j = i + 1;j < lines.length;j++) {
                if (lines[j].includes('<name>')) {
                    typeList.forEach(function(typeName) {
                        if (lines[j].includes('<name>' + typeName + '</name>')) {
                            hideThis = !hideThis;
                        }
                    });
                    break;
                }
            }
        } else if (lines[i].includes('<version>')) {
            // If this line is the version, then we want to make sure hiding is off.
            hideThis = false;
        }
        if (!hideThis) {
            var showThis = true;
            memberList.forEach(function(memberName) {
                if (lines[i].includes('<members>' + memberName + '</members>')) {
                    // If this member is listed, we want it gone (no matter if we are in exclude or isolate mode)
                    showThis = false;
                }
            });
            if (showThis) {
                outputStr += lines[i] + '\n';
            }
        }
    }

    // Write the output to the file specified
    fs.writeFile(outFile, outputStr, 'utf8', function(err) {
        if (err) {
            return console.log(err);
        }
    });
});
